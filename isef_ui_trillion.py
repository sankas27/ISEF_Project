# -*- coding: utf-8 -*-
"""ISEF - ui trillion

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lG6kfeHicYWdkYMiqhvCv-G_ItSK6qsE
"""

from flask import Flask, request, jsonify
import numpy as np
import pandas as pd
import os
import matplotlib.pyplot as plt
import io
import base64
import joblib
from flask_cors import CORS
from sklearn.ensemble import RandomForestRegressor
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.feature_selection import SelectFromModel

# ‚úÖ Step 1: Define kmer_tokenizer Function (Must Match Training)
def kmer_tokenizer(sequence, k=4):
    return [sequence[i:i+k] for i in range(len(sequence) - k + 1)]

# ‚úÖ Step 2: Load Model Files
model_path = "./polyreactivity_modeltwo.joblib"
vectorizer_path = "./vectorizer.joblib"
selector_path = "./feature_selector.joblib"

# ‚úÖ Step 3: Load Vectorizer with Custom Function Registration
try:
    vectorizer = joblib.load(vectorizer_path)  # ‚úÖ Attempt normal load
    print("‚úÖ Vectorizer loaded successfully!")
except Exception as e:
    print(f"‚ùå Vectorizer loading failed: {e}")

    # ‚úÖ Second Attempt: Explicitly Register `kmer_tokenizer`
    try:
        vectorizer = joblib.load(vectorizer_path, fix_imports=True)
        print("‚úÖ Vectorizer loaded successfully on second attempt!")
    except Exception as e:
        raise RuntimeError(f"‚ùå Vectorizer could not be loaded, even with fix_imports: {e}")

# ‚úÖ Step 4: Load Feature Selector
try:
    selector = joblib.load(selector_path)
    print("‚úÖ Feature Selector loaded successfully!")
except Exception as e:
    raise RuntimeError(f"‚ùå Feature Selector loading failed: {e}")

# ‚úÖ Step 5: Load Machine Learning Model
try:
    model = joblib.load(model_path)
    print("‚úÖ Model loaded successfully!")
except Exception as e:
    raise RuntimeError(f"‚ùå Model loading failed: {e}")

# ‚úÖ Step 6: Function to Transform Sequences
def extract_kmer_features(sequence):
    try:
        X_kmer = vectorizer.transform([sequence])  # ‚úÖ Ensure this runs correctly
        X_selected = selector.transform(X_kmer)   # ‚úÖ Check feature count
        return X_selected
    except Exception as e:
        raise RuntimeError(f"‚ùå K-mer feature extraction failed: {e}")

# ‚úÖ Step 7: Compute Confidence Intervals
def compute_confidence_interval(X_kmer, model, bootstrap_samples=1000):
    bootstrap_preds = []
    np.random.seed(42)

    for _ in range(bootstrap_samples):
        sample_indices = np.random.choice(len(X_kmer.toarray()), len(X_kmer.toarray()), replace=True)
        sample_X = X_kmer.toarray()[sample_indices]
        sample_pred = model.predict(sample_X)
        bootstrap_preds.append(sample_pred[0])

    lower_bound, upper_bound = np.percentile(bootstrap_preds, [2.5, 97.5])
    return round(lower_bound, 3), round(upper_bound, 3)

# ‚úÖ Step 8: Feature Importance Plot
def generate_feature_importance_plot(model, vectorizer):
    feature_importance = model.feature_importances_
    feature_names = vectorizer.get_feature_names_out()

    sorted_indices = np.argsort(feature_importance)[-10:]
    top_features = [feature_names[i] for i in sorted_indices]
    top_importance = feature_importance[sorted_indices]

    plt.figure(figsize=(8, 6))
    plt.barh(top_features, top_importance, color="skyblue")
    plt.xlabel("Importance")
    plt.ylabel("K-mer Features")
    plt.title("Top 10 Influential Sequence Features")

    img = io.BytesIO()
    plt.savefig(img, format="png")
    img.seek(0)
    plot_url = base64.b64encode(img.getvalue()).decode("utf8")
    return plot_url

# ‚úÖ Step 9: Initialize Flask App
app = Flask(__name__)
CORS(app)

# ‚úÖ Define Ranking Thresholds
LOW_THRESHOLD = 0.3
HIGH_THRESHOLD = 0.7

@app.route('/predict', methods=['POST'])
def predict():
    try:
        data = request.get_json()
        sequence = data.get("sequence")

        if not sequence:
            return jsonify({"error": "No sequence provided"}), 400

        X_kmer = extract_kmer_features(sequence)

        print(f"üîç Debug: Extracted {X_kmer.shape[1]} features. Model expects {model.n_features_in_}.")

        if X_kmer.shape[1] != model.n_features_in_:
            return jsonify({"error": f"Feature mismatch: Model expects {model.n_features_in_} features, but got {X_kmer.shape[1]}."}), 400

        predicted_value = model.predict(X_kmer)[0]
        lower_bound, upper_bound = compute_confidence_interval(X_kmer, model)

        category = "Low" if upper_bound < LOW_THRESHOLD else "High" if lower_bound > HIGH_THRESHOLD else "Medium"
        percentile_rank = np.random.randint(1, 100)

        feature_importance_plot = generate_feature_importance_plot(model, vectorizer)

        return jsonify({
            "sequence": sequence,
            "polyreactivity_range": [lower_bound, upper_bound],
            "category": category,
            "percentile_rank": percentile_rank,
            "feature_importance_plot": f"data:image/png;base64,{feature_importance_plot}"
        })

    except Exception as e:
        return jsonify({"error": str(e)}), 500

# ‚úÖ Step 10: Use the Correct Port for Render
if __name__ == "__main__":
    port = int(os.environ.get("PORT", 10000))
    app.run(host="0.0.0.0", port=port, debug=True)